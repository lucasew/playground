**SPEC: Remote Browser Service**

## Visão Geral

Serviço em Go que spawna browsers headless isolados por usuário e streama HTML para clientes remotos via Server-Sent Events (SSE). Cada usuário tem profile isolado com múltiplas tabs gerenciadas independentemente.

## Stack Técnica

- **Backend:** Go + chromedp + cobra + gorilla/mux
- **Frontend:** HTML/CSS/JS (PWA)
- **Auth:** HTTP Basic Auth
- **Config:** YAML
- **Streaming:** Server-Sent Events (SSE)

---

## Arquitetura

### 1. CLI (cobra)

```bash
remotebrowser serve [flags]
  --config string     Caminho do config.yaml (default: "config.yaml")
  --state string      Diretório de profiles do Chrome (default: <config_dir>/profiles)
  --port int          Porta do servidor HTTP (default: 8080)
  --host string       Host para bind (default: "0.0.0.0")
```

**Exemplos:**

```bash
remotebrowser serve
remotebrowser serve --config /etc/remotebrowser/config.yaml --port 3000
remotebrowser serve --state /var/lib/remotebrowser/profiles
```

---

### 2. Estruturas de Dados

```go
// Config (config.yaml)
type Config struct {
    Users map[string]string `yaml:"users"`  // username: password (plaintext no MVP)
}

// AppInputs
type AppInputs struct {
    StateDir string
    Config   *Config
    Port     int
    Host     string
}

// App (implements http.Handler)
type App struct {
    inputs   AppInputs
    sessions map[string]*UserSession  // userID -> session
    mu       sync.RWMutex
}

// UserSession
type UserSession struct {
    userID       string
    browserCtx   context.Context
    cancelFunc   context.CancelFunc
    profileDir   string
    tabs         map[string]*Tab       // tabID -> tab
    activeTabID  string
    mu           sync.RWMutex
    
    // SSE clients
    tabListeners map[string][]chan SSEMessage  // tabID -> lista de canais SSE
    listListener []chan SSEMessage             // listeners da lista de tabs
}

// Tab
type Tab struct {
    id           string
    ctx          context.Context
    cancelFunc   context.CancelFunc
    url          string
    title        string
    lastHTML     string
    lastHTMLHash string  // para detectar mudanças
}

// SSEMessage
type SSEMessage struct {
    Event string      // "html" ou "tabs"
    Data  interface{} // será serializado como JSON
}
```

---

### 3. API HTTP

#### Endpoints

| Método | Path                           | Auth | Descrição                         |
| ------ | ------------------------------ | ---- | --------------------------------- |
| GET    | `/`                            | Não  | Serve cliente HTML/JS/CSS         |
| GET    | `/api/stream/{userID}/{tabID}` | Sim  | SSE: stream de HTML da tab        |
| GET    | `/api/tabs/{userID}`           | Sim  | SSE: stream da lista de tabs      |
| POST   | `/api/action/{userID}/{tabID}` | Sim  | Comandos específicos da tab       |
| POST   | `/api/action/{userID}`         | Sim  | Comandos globais (gerenciar tabs) |
| GET    | `/api/health`                  | Não  | Healthcheck                       |

#### Autenticação

- **Tipo:** HTTP Basic Auth
- **Validação:** `userID` no path deve coincidir com username do Basic Auth
- **Resposta 401:** Se credenciais inválidas ou userID não bate

**Flow:**

1. Cliente envia `Authorization: Basic base64(user:pass)`
2. Servidor valida via `App.ValidateUser(user, pass)`
3. Servidor verifica se `userID` no path == `user` autenticado
4. Se válido, processa request

---

### 4. Server-Sent Events (SSE)

#### 4.1. HTML Stream

**Endpoint:** `GET /api/stream/{userID}/{tabID}`

**Headers de Resposta:**

```
Content-Type: text/event-stream
Cache-Control: no-cache
Connection: keep-alive
```

**Evento:**

```
event: html
data: {"content": "<html>...</html>"}
```

**Comportamento:**

- Envia HTML completo sempre que detectar mudança
- Polling interno a cada 500ms capturando `document.documentElement.innerHTML`
- Compara hash SHA256 do HTML antes de enviar
- Só envia se hash diferir do anterior
- Se tab não existir, retorna 404

**Cliente:**

```javascript
const stream = new EventSource('/api/stream/alice/tab-123');
stream.addEventListener('html', (e) => {
  const data = JSON.parse(e.data);
  document.documentElement.innerHTML = data.content;
});
```

---

#### 4.2. Tabs Stream

**Endpoint:** `GET /api/tabs/{userID}`

**Headers de Resposta:**

```
Content-Type: text/event-stream
Cache-Control: no-cache
Connection: keep-alive
```

**Evento:**

```
event: tabs
data: {
  "activeTabID": "tab-123",
  "tabs": [
    {"id": "tab-123", "title": "Google", "url": "https://google.com"},
    {"id": "tab-456", "title": "GitHub", "url": "https://github.com"}
  ]
}
```

**Comportamento:**

- Envia lista completa sempre que houver mudança:
  - Nova tab criada
  - Tab fechada
  - Tab ativa mudou
  - Título ou URL de alguma tab mudou
- Cliente faz diff e atualiza UI

**Cliente:**

```javascript
const tabsStream = new EventSource('/api/tabs/alice');
tabsStream.addEventListener('tabs', (e) => {
  const data = JSON.parse(e.data);
  updateTabList(data.tabs);
  highlightActiveTab(data.activeTabID);
});
```

---

### 5. Actions API

#### 5.1. Tab-Specific Actions

**Endpoint:** `POST /api/action/{userID}/{tabID}`

**Request Body (JSON):**

```json
// Navegar para URL
{"action": "navigate", "url": "https://example.com"}

// Click em coordenada
{"action": "click", "x": 100, "y": 200}

// Digitar texto (no elemento focado)
{"action": "type", "text": "hello world"}

// Scroll absoluto
{"action": "scrollTo", "x": 0, "y": 500}
```

**Response:**

- **200 OK:** `{"success": true}`
- **400 Bad Request:** JSON inválido ou action desconhecida
- **404 Not Found:** Tab não existe
- **500 Internal Server Error:** Erro ao executar no chromedp

**Implementação:**

| Action     | Implementação chromedp                                                 |
| ---------- | ---------------------------------------------------------------------- |
| `navigate` | `chromedp.Navigate(url)`                                               |
| `click`    | `chromedp.MouseClickXY(x, y)`                                          |
| `type`     | `chromedp.SendKeys(selector, text)` ou focus + SendKeys                |
| `scrollTo` | `chromedp.Evaluate(fmt.Sprintf("window.scrollTo(%d, %d)", x, y), nil)` |

---

#### 5.2. Global Actions

**Endpoint:** `POST /api/action/{userID}`

**Request Body (JSON):**

```json
// Criar nova tab
{"action": "newTab", "url": "https://google.com"}

// Trocar tab ativa
{"action": "switchTab", "tabId": "tab-123"}

// Fechar tab
{"action": "closeTab", "tabId": "tab-456"}
```

**Response:**

**newTab:**

```json
{"success": true, "tabId": "tab-789"}
```

**switchTab / closeTab:**

```json
{"success": true}
```

**Erros:**

- **400:** JSON inválido ou action desconhecida
- **404:** Tab não encontrada (para switchTab/closeTab)
- **500:** Erro interno

**Comportamento:**

- `newTab`: Cria novo contexto chromedp, gera UUID único, navega para URL, adiciona à lista, envia update via tabs SSE
- `switchTab`: Atualiza `activeTabID`, envia update via tabs SSE
- `closeTab`: Cancela contexto chromedp, remove da lista, se era activeTab escolhe outra, envia update via tabs SSE

---

### 6. Fluxo de Autenticação e Sessão

**1. Cliente conecta:**

```
Authorization: Basic YWxpY2U6c2VuaGExMjM=  (alice:senha123)
```

**2. Middleware valida:**

```go
func (a *App) authMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        user, pass, ok := r.BasicAuth()
        if !ok || !a.ValidateUser(user, pass) {
            w.Header().Set("WWW-Authenticate", `Basic realm="Remote Browser"`)
            w.WriteHeader(401)
            return
        }
        
        // Verifica se userID no path bate com user autenticado
        vars := mux.Vars(r)
        if pathUser, exists := vars["userID"]; exists && pathUser != user {
            w.WriteHeader(403)
            return
        }
        
        ctx := context.WithValue(r.Context(), "userID", user)
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}
```

**3. Cria/recupera sessão:**

```go
session := a.getOrCreateSession(userID)
```

**4. Profile isolado:**

- Path: `{stateDir}/chrome-profile-{userID}`
- chromedp options: `chromedp.UserDataDir(profileDir)`
- Isolamento: cookies, localStorage, cache, histórico

---

### 7. Browser Management

#### Lifecycle da UserSession

**Criação:**

```go
func (a *App) getOrCreateSession(userID string) *UserSession {
    a.mu.Lock()
    defer a.mu.Unlock()
    
    if session, exists := a.sessions[userID]; exists {
        return session
    }
    
    profileDir := filepath.Join(a.inputs.StateDir, "chrome-profile-"+userID)
    os.MkdirAll(profileDir, 0755)
    
    opts := append(chromedp.DefaultExecAllocatorOptions[:],
        chromedp.UserDataDir(profileDir),
        chromedp.Flag("headless", true),
    )
    
    allocCtx, cancel := chromedp.NewExecAllocator(context.Background(), opts...)
    browserCtx, _ := chromedp.NewContext(allocCtx)
    
    session := &UserSession{
        userID:       userID,
        browserCtx:   browserCtx,
        cancelFunc:   cancel,
        profileDir:   profileDir,
        tabs:         make(map[string]*Tab),
        tabListeners: make(map[string][]chan SSEMessage),
        listListener: make([]chan SSEMessage, 0),
    }
    
    a.sessions[userID] = session
    return session
}
```

**Cleanup:**

- Ao desconectar todas SSE connections de um usuário (timeout?)
- Ou comando explícito de logout
- Cancela `browserCtx`, limpa `tabs`, opcionalmente remove `profileDir`

---

### 8. Tab Management

#### Criar Tab

```go
func (s *UserSession) createTab(url string) (string, error) {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    tabID := uuid.New().String()
    tabCtx, cancel := chromedp.NewContext(s.browserCtx)
    
    tab := &Tab{
        id:         tabID,
        ctx:        tabCtx,
        cancelFunc: cancel,
        url:        url,
    }
    
    // Navega e captura título
    err := chromedp.Run(tabCtx,
        chromedp.Navigate(url),
        chromedp.WaitReady("body"),
        chromedp.Title(&tab.title),
    )
    
    if err != nil {
        cancel()
        return "", err
    }
    
    s.tabs[tabID] = tab
    if s.activeTabID == "" {
        s.activeTabID = tabID
    }
    
    s.notifyTabListChange()
    return tabID, nil
}
```

#### Fechar Tab

```go
func (s *UserSession) closeTab(tabID string) error {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    tab, exists := s.tabs[tabID]
    if !exists {
        return errors.New("tab not found")
    }
    
    tab.cancelFunc()
    delete(s.tabs, tabID)
    
    // Se era ativa, escolhe outra
    if s.activeTabID == tabID {
        for id := range s.tabs {
            s.activeTabID = id
            break
        }
    }
    
    s.notifyTabListChange()
    return nil
}
```

---

### 9. HTML Streaming Implementation

**Goroutine por tab ativa:**

```go
func (s *UserSession) streamHTML(tabID string, msgChan chan SSEMessage) {
    ticker := time.NewTicker(500 * time.Millisecond)
    defer ticker.Stop()
    
    tab := s.tabs[tabID]
    if tab == nil {
        return
    }
    
    for {
        select {
        case <-ticker.C:
            var html string
            err := chromedp.Run(tab.ctx,
                chromedp.InnerHTML("html", &html, chromedp.ByQuery),
            )
            
            if err != nil {
                continue
            }
            
            // Compara hash
            hash := sha256Hash(html)
            if hash != tab.lastHTMLHash {
                tab.lastHTML = html
                tab.lastHTMLHash = hash
                
                msgChan <- SSEMessage{
                    Event: "html",
                    Data:  map[string]string{"content": html},
                }
            }
            
        case <-tab.ctx.Done():
            return
        }
    }
}
```

---

### 10. Estrutura de Arquivos

```
remotebrowser/
├── cmd/
│   └── remotebrowser/
│       └── main.go              # Entry point + cobra setup
├── internal/
│   ├── app/
│   │   ├── app.go              # App struct + http.Handler + routing
│   │   ├── auth.go             # Auth middleware
│   │   ├── session.go          # UserSession struct + métodos
│   │   ├── tab.go              # Tab struct + management
│   │   └── sse.go              # SSE helpers + streaming logic
│   ├── config/
│   │   └── config.go           # YAML loading + Config struct
│   └── handlers/
│       ├── stream.go           # SSE handlers (HTML + tabs)
│       ├── action.go           # Action handlers (POST)
│       └── health.go           # Healthcheck
├── web/
│   ├── index.html              # Cliente SPA
│   ├── app.js                  # Lógica do cliente (SSE + actions)
│   ├── style.css               # UI básica
│   └── manifest.json           # PWA manifest
├── config.yaml                 # Exemplo de configuração
├── go.mod
├── go.sum
├── README.md
└── .gitignore
```

---

### 11. config.yaml

```yaml
# Remote Browser Configuration
# Senhas em plaintext no MVP - migrar para bcrypt depois

users:
  alice: senha123
  bob: outrasenha
  carlos: maisuma
```

**Loading:**

```go
func LoadConfig(path string) (*Config, error) {
    data, err := os.ReadFile(path)
    if err != nil {
        return nil, fmt.Errorf("read config: %w", err)
    }
    
    var cfg Config
    if err := yaml.Unmarshal(data, &cfg); err != nil {
        return nil, fmt.Errorf("parse config: %w", err)
    }
    
    if len(cfg.Users) == 0 {
        return nil, errors.New("no users defined in config")
    }
    
    return &cfg, nil
}
```

---

## Implementação MVP

### Fase 1: Estrutura Básica ✓

- [ ] Inicializar projeto Go com módulos
- [ ] Setup cobra CLI com comando `serve`
- [ ] Implementar loading de config.yaml
- [ ] Criar estrutura `App` com `http.Handler`
- [ ] Setup gorilla/mux para routing
- [ ] Middleware de Basic Auth
- [ ] Endpoint `/api/health` (retorna `{"status": "ok"}`)
- [ ] Servir arquivos estáticos de `/web` em `/`

### Fase 2: Browser Management ✓

- [ ] Implementar `UserSession.create()` com chromedp
- [ ] Profile isolado via `UserDataDir`
- [ ] Gerenciar lifecycle (create/cleanup)
- [ ] Map `sessions` em `App` com mutex
- [ ] `getOrCreateSession()` lazy initialization
- [ ] Cleanup ao desconectar (timeout de inatividade)

### Fase 3: Tab Management ✓

- [ ] Implementar `Tab` struct
- [ ] `UserSession.createTab(url)` com UUID
- [ ] `UserSession.closeTab(tabID)`
- [ ] `UserSession.switchTab(tabID)`
- [ ] Manter `activeTabID`
- [ ] Capturar título da página ao criar tab

### Fase 4: SSE - HTML Stream ✓

- [ ] Handler `GET /api/stream/{userID}/{tabID}`
- [ ] Setup SSE headers e flush
- [ ] Goroutine de polling (500ms)
- [ ] Capturar HTML com `chromedp.InnerHTML`
- [ ] Hash SHA256 para detectar mudanças
- [ ] Enviar só se hash diferir
- [ ] Cleanup ao fechar conexão SSE

### Fase 5: SSE - Tabs Stream ✓

- [ ] Handler `GET /api/tabs/{userID}`
- [ ] Setup SSE headers e flush
- [ ] Broadcast de mudanças na lista de tabs
- [ ] Enviar estado completo (activeTabID + lista)
- [ ] Trigger ao criar/fechar/switch tab
- [ ] Atualizar título periodicamente (polling 5s)

### Fase 6: Actions - Tab-Specific ✓

- [ ] Handler `POST /api/action/{userID}/{tabID}`
- [ ] Parse JSON body
- [ ] Implementar `navigate` com `chromedp.Navigate`
- [ ] Implementar `click` com `chromedp.MouseClickXY`
- [ ] Implementar `type` com `chromedp.SendKeys`
- [ ] Implementar `scrollTo` com `chromedp.Evaluate`
- [ ] Validação de payload
- [ ] Error handling e responses

### Fase 7: Actions - Global ✓

- [ ] Handler `POST /api/action/{userID}`
- [ ] Implementar `newTab` (retorna tabID)
- [ ] Implementar `switchTab`
- [ ] Implementar `closeTab`
- [ ] Trigger tabs SSE após cada ação
- [ ] Validação de tabID existence

### Fase 8: Cliente Web (PWA) ✓

- [ ] HTML básico com UI de tabs
- [ ] EventSource para `/api/tabs/{userID}`
- [ ] Renderizar lista de tabs dinamicamente
- [ ] EventSource para `/api/stream/{userID}/{tabID}` da tab ativa
- [ ] Fechar/reabrir HTML stream ao trocar tab
- [ ] Capturar eventos (click, keypress, scroll)
- [ ] Enviar actions via `fetch` POST
- [ ] CSS básico responsivo
- [ ] `manifest.json` para PWA
- [ ] Service worker para offline (opcional)

### Fase 9: Polish ✓

- [ ] Logs estruturados (slog ou logrus)
- [ ] Graceful shutdown
- [ ] Timeout de inatividade de sessão (30min)
- [ ] Rate limiting básico (opcional)
- [ ] Documentação no README
- [ ] Dockerfile
- [ ] Testes básicos (opcional no MVP)

---

## Dependências

```bash
# Core
go get github.com/chromedp/chromedp
go get github.com/spf13/cobra
go get gopkg.in/yaml.v3
go get github.com/gorilla/mux

# Utilities
go get github.com/google/uuid
```

---

## Comandos de Desenvolvimento

```bash
# Inicializar módulo
go mod init github.com/seu-usuario/remotebrowser

# Instalar dependências
go mod tidy

# Rodar em dev
go run cmd/remotebrowser/main.go serve

# Build
go build -o remotebrowser cmd/remotebrowser/main.go

# Rodar com custom config
./remotebrowser serve --config /path/to/config.yaml --port 3000

# Docker build
docker build -t remotebrowser .
docker run -p 8080:8080 -v $(pwd)/config.yaml:/config.yaml remotebrowser
```

---

## Cliente JavaScript - Exemplo Completo

```javascript
class RemoteBrowser {
    constructor(userID) {
        this.userID = userID;
        this.currentTabID = null;
        this.htmlStream = null;
        this.tabsStream = null;
        
        this.initTabsStream();
    }
    
    initTabsStream() {
        this.tabsStream = new EventSource(`/api/tabs/${this.userID}`);
        this.tabsStream.addEventListener('tabs', (e) => {
            const data = JSON.parse(e.data);
            this.updateTabList(data.tabs);
            
            // Se tab ativa mudou, reconecta HTML stream
            if (data.activeTabID !== this.currentTabID) {
                this.switchToTab(data.activeTabID);
            }
        });
    }
    
    switchToTab(tabID) {
        // Fecha stream anterior
        if (this.htmlStream) {
            this.htmlStream.close();
        }
        
        this.currentTabID = tabID;
        
        // Abre novo stream
        this.htmlStream = new EventSource(`/api/stream/${this.userID}/${tabID}`);
        this.htmlStream.addEventListener('html', (e) => {
            const data = JSON.parse(e.data);
            document.getElementById('browser-content').innerHTML = data.content;
        });
    }
    
    async sendAction(action, tabID = null) {
        const url = tabID 
            ? `/api/action/${this.userID}/${tabID}`
            : `/api/action/${this.userID}`;
            
        const response = await fetch(url, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(action)
        });
        
        return response.json();
    }
    
    async newTab(url) {
        const result = await this.sendAction({action: 'newTab', url});
        return result.tabId;
    }
    
    async closeTab(tabID) {
        await this.sendAction({action: 'closeTab', tabId: tabID});
    }
    
    async navigate(url) {
        await this.sendAction({action: 'navigate', url}, this.currentTabID);
    }
    
    async click(x, y) {
        await this.sendAction({action: 'click', x, y}, this.currentTabID);
    }
    
    updateTabList(tabs) {
        const tabList = document.getElementById('tab-list');
        tabList.innerHTML = '';
        
        tabs.forEach(tab => {
            const tabEl = document.createElement('div');
            tabEl.className = 'tab';
            tabEl.textContent = tab.title;
            tabEl.onclick = () => this.sendAction({action: 'switchTab', tabId: tab.id});
            tabList.appendChild(tabEl);
        });
    }
}

// Uso
const browser = new RemoteBrowser('alice');
```

---

## Melhorias Futuras (Pós-MVP)

### Segurança

- [ ] Bcrypt para senhas no config.yaml
- [ ] JWT em vez de Basic Auth
- [ ] TLS/HTTPS obrigatório
- [ ] Rate limiting por usuário
- [ ] CORS configurável

### Performance

- [ ] DOM diffing (sergi/go-diff) em vez de HTML completo
- [ ] Compressão de HTML (gzip)
- [ ] Debounce de eventos do cliente
- [ ] Pool de browsers pré-inicializados

### Features

- [ ] Upload/download de arquivos
- [ ] Screenshots on-demand
- [ ] Session persistence (salvar tabs ao desconectar)
- [ ] Histórico de navegação
- [ ] Bookmarks compartilhados
- [ ] Multi-user collaboration (mesma tab)

### Observability

- [ ] Métricas Prometheus (sessões ativas, tabs, latência)
- [ ] Structured logging com níveis
- [ ] Tracing distribuído
- [ ] Dashboard de admin

### DevOps

- [ ] Docker Compose com Chrome headless otimizado
- [ ] Kubernetes deployment
- [ ] Health checks avançados
- [ ] Backup automático de profiles
- [ ] CI/CD pipeline

---

## Notas de Implementação

### Tratamento de Erros

- Todas as operações chromedp devem ter timeout (5-10s)
- SSE deve reconectar automaticamente (built-in do EventSource)
- Logs estruturados para debug
- Graceful degradation se browser crashar

### Concorrência

- Usar `sync.RWMutex` em `UserSession.tabs`
- Cada SSE connection em goroutine separada
- Channel para broadcast de mudanças
- Context cancellation para cleanup

### Recursos

- Limitar número de tabs por usuário (ex: 10)
- Limitar número de sessões simultâneas
- Cleanup de profiles antigos (cron job)
- Monitorar uso de memória/CPU
